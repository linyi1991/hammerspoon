-- ~/.hammerspoon/scripts/ç¥ˆç¦±æ©Ÿ-æ´»7-æ–½æ”¾è¢«å‹•æŠ€èƒ½.lua
-- æ›´æ–°ç‰ˆï¼šæŠ€èƒ½æ™‚é•·ã€é–’ç½®5ç§’ã€æ›æ©Ÿ280ç§’ã€å‰©30ç§’è­¦å‘Š

local mod = {}

----------------------------------------------------------------------
-- åƒæ•¸ï¼ˆå¯æ”¹ï¼‰
----------------------------------------------------------------------
local TARGET_APP_NAME   = "MapleStory"
local REQUIRE_FRONTMOST = false     -- æ˜¯å¦åªåœ¨éŠæˆ²å‰æ™¯æ‰æ–½æ”¾ï¼Ÿ
local FOCUS_ON_CAST     = true      -- æ–½æ”¾å‰æ˜¯å¦å˜—è©¦èšç„¦éŠæˆ²
local TICK_SEC          = 0.5       -- æª¢æŸ¥é »ç‡ï¼ˆç§’ï¼‰

-- æŠ€èƒ½èˆ‡æœ‰æ•ˆæ™‚é–“ï¼ˆç§’ï¼‰
local SKILLS = {
  { name="skill1", key="1", duration=300 },  -- æŠ€èƒ½1ï¼š300ç§’
  { name="skill2", key="2", duration=200 },  -- æŠ€èƒ½2ï¼š200ç§’
}

-- åˆ°æœŸå‰ 5~10% é å…ˆé‡è£œ
local EARLY_PCT_MIN, EARLY_PCT_MAX = 0.05, 0.10

-- å·¦å³è¼•é»ï¼ˆå…ˆå·¦â†’å³ï¼‰
local WIGGLE_HOLD_MS = { 50, 70 }
local WIGGLE_GAP_S   = { 0.05, 0.10 }

-- é€éµæ‰‹æ„Ÿ
local PRE_KEY_DELAY_S   = { 0.04, 0.12 }
local PRESS_MS          = { 150, 200 }
local SAFEGUARD_REPRESS = true
local REPRESS_GAP_S     = { 0.075, 0.118 }

-- ã€Œå…ˆ â†‘ã€å† âŒ¥â†ã€âŒ¥â†’ã€çš„æ™‚åºï¼ˆå«æŠ–å‹•ï¼‰
local T_BEFORE_UP   = 1.2
local T_AFTER_UP    = 2.0
local T_BETWEEN_OPT = 0.55
local JITTER_PCT    = 0.20

-- ğŸ”” æ›æ©Ÿè¦å‰‡
local HUMAN_GRACE_SEC = 5         -- é–’ç½®5ç§’å¾Œæ‰é–‹å§‹æ›æ©Ÿå€’æ•¸
local IDLE_TOTAL_SEC  = 280       -- æ›æ©Ÿå€’æ•¸ç¸½ç§’æ•¸ï¼ˆ280ç§’ï¼‰
local IDLE_WARN_LAST  = 30        -- å‰©ä¸‹30ç§’é–‹å§‹æ¯ç§’è­¦å‘Š
local IDLE_OS_ACTIVE_THRESHOLD = 0.8 -- ï¼ˆå¯ä¿ç•™ä½†æ­¤ç‰ˆä»¥ idleTime ç‚ºä¸»ï¼‰

-- é™¤éŒ¯
local DEBUG = true
local function log(...) if DEBUG then print("[skillbot]", ...) end end

----------------------------------------------------------------------
-- å°å·¥å…·
----------------------------------------------------------------------
math.randomseed(os.time())
local function randf(a,b) return a + math.random()*(b-a) end
local function randi(a,b) return math.floor(a + math.random()*(b-a+1)) end
local function jitterp(base,pct) return math.max(0.01, base*(1+(math.random()*2-1)*pct)) end
local function fmt_mmss(sec)
  sec = math.max(0, math.floor(sec or 0))
  local m = math.floor(sec / 60)
  local s = sec % 60
  return string.format("%d:%02d", m, s)
end

-- menubarï¼ˆé¡¯ç¤ºï¼šè£œæ–½ï¼æ›æ©Ÿ mm:ssï¼‰
local menuBar = nil
local function ensureMenuBar()
  if menuBar then return end
  menuBar = hs.menubar.new()
  if menuBar then menuBar:setTitle("å¾…æ©Ÿ") end
end
local function setBar(text) ensureMenuBar(); if menuBar then menuBar:setTitle(text) end end

local function focusApp()
  if not FOCUS_ON_CAST then return end
  local app = hs.appfinder.appFromName(TARGET_APP_NAME)
  if app then app:activate(true) end
end

local function ensureFrontmostIfNeeded()
  if not REQUIRE_FRONTMOST then return true end
  local fw = hs.window.frontmostWindow()
  local app = fw and fw:application()
  return app and app:name() == TARGET_APP_NAME
end

local function releaseAllModifiers()
  for _,m in ipairs({"alt","cmd","ctrl","shift","fn"}) do
    hs.eventtap.event.newKeyEvent({}, m, false):post()
  end
end

local function settleBeforeNumbers()
  hs.timer.usleep(90*1000)
  releaseAllModifiers()
  hs.timer.usleep(110*1000)
  focusApp()
  hs.timer.usleep(160*1000)
end

----------------------------------------------------------------------
-- é€éµ
----------------------------------------------------------------------
local function rawKeyPress(keyChar, press_ms)
  hs.timer.usleep(randf(PRE_KEY_DELAY_S[1], PRE_KEY_DELAY_S[2]) * 1e6)
  local down = hs.eventtap.event.newKeyEvent({}, keyChar, true)
  down:setProperty(hs.eventtap.event.properties.keyboardEventAutorepeat, 0)
  down:post()
  hs.timer.usleep((press_ms or randi(PRESS_MS[1], PRESS_MS[2])) * 1000)
  local up = hs.eventtap.event.newKeyEvent({}, keyChar, false)
  up:setProperty(hs.eventtap.event.properties.keyboardEventAutorepeat, 0)
  up:post()
  hs.timer.usleep(randi(20,80) * 1000)
end

local function wiggleLR()
  rawKeyPress("left",  randi(WIGGLE_HOLD_MS[1], WIGGLE_HOLD_MS[2]))
  hs.timer.usleep(randf(WIGGLE_GAP_S[1], WIGGLE_GAP_S[2]) * 1e6)
  rawKeyPress("right", randi(WIGGLE_HOLD_MS[1], WIGGLE_HOLD_MS[2]))
end

local function modCombo(mods, keyChar, press_ms, pre_hold_ms, post_hold_ms)
  press_ms     = press_ms     or 60
  pre_hold_ms  = pre_hold_ms or 60
  post_hold_ms = post_hold_ms or 60
  for _, m in ipairs(mods or {}) do hs.eventtap.event.newKeyEvent({}, m, true):post() end
  hs.timer.usleep(pre_hold_ms * 1000)
  local kc = hs.keycodes.map[keyChar] or keyChar
  hs.eventtap.event.newKeyEvent({}, kc, true):post()
  hs.timer.usleep(press_ms * 1000)
  hs.eventtap.event.newKeyEvent({}, kc, false):post()
  hs.timer.usleep(post_hold_ms * 1000)
  for i = #(mods or {}), 1, -1 do
    hs.eventtap.event.newKeyEvent({}, (mods or {})[i], false):post()
  end
end

----------------------------------------------------------------------
-- æ–½æ”¾ï¼šâ†‘ â†’ âŒ¥â† â†’ âŒ¥â†’ â†’ å°æ™ƒ â†’ æ•¸å­—éµï¼ˆå«è£œæŒ‰ï¼‰
----------------------------------------------------------------------
local function castOne(skill)
  if not ensureFrontmostIfNeeded() then return false end
  settleBeforeNumbers()

  -- ä¸Š â†‘
  hs.timer.usleep(jitterp(T_BEFORE_UP, JITTER_PCT) * 1e6)
  rawKeyPress("up", 60)
  hs.timer.usleep(jitterp(T_AFTER_UP, JITTER_PCT) * 1e6)

  -- âŒ¥â† â†’ âŒ¥â†’
  modCombo({"alt"}, "left", 60, 60, 60)
  hs.timer.usleep(jitterp(T_BETWEEN_OPT, JITTER_PCT) * 1e6)
  modCombo({"alt"}, "right", 60, 60, 60)

  -- å·¦å³å°æ™ƒ
  wiggleLR()

  -- æ–½æ”¾æ•¸å­—éµï¼ˆå«ä¸€æ¬¡è£œæŒ‰ï¼‰
  local p = randi(PRESS_MS[1], PRESS_MS[2])
  rawKeyPress(skill.key, p)
  if SAFEGUARD_REPRESS then
    hs.timer.usleep(randf(REPRESS_GAP_S[1], REPRESS_GAP_S[2]) * 1e6)
    rawKeyPress(skill.key, math.max(140, p - 10))
  end

  log("cast:", skill.name, "key", skill.key)
  return true
end

----------------------------------------------------------------------
-- èª¿åº¦ç‹€æ…‹
----------------------------------------------------------------------
local enabled, ticker = false, nil
local state = {}

local function scheduleNext(skill, baseEpoch)
  local e = randf(EARLY_PCT_MIN, EARLY_PCT_MAX)
  local due = baseEpoch + skill.duration * (1.0 - e)
  state[skill.name] = { nextDue = due, earlyPct = e }
  log(string.format("next %s in %.1fs (early %.1f%%)",
      skill.name, due - baseEpoch, e*100))
end

local function nearestRemaining()
  local now = hs.timer.secondsSinceEpoch()
  local best = nil
  for _, sk in ipairs(SKILLS) do
    local st = state[sk.name]
    if st and st.nextDue then
      local remain = math.max(0, math.floor(st.nextDue - now))
      best = (best == nil) and remain or math.min(best, remain)
    end
  end
  return best
end

----------------------------------------------------------------------
-- æ›æ©Ÿåµæ¸¬ï¼šä½¿ç”¨ hs.host.idleTime()
----------------------------------------------------------------------
local lastWarnShown = -1

local function currentIdleRemain(now)
  local idleSecs = hs.host.idleTime() or 0  -- ç³»çµ±ç„¡å‹•ä½œç§’æ•¸  [oai_citation:0â€¡Hammerspoon](https://www.hammerspoon.org/docs/hs.host.html?utm_source=chatgpt.com)
  log("â€¦ system idle time = " .. string.format("%.1f", idleSecs))
  if idleSecs < HUMAN_GRACE_SEC then
    return nil
  end
  local remain = IDLE_TOTAL_SEC - math.floor(idleSecs - HUMAN_GRACE_SEC)
  if remain < 0 then remain = 0 end
  return remain
end

----------------------------------------------------------------------
-- é¡¯ç¤ºï¼šè£œæ–½ + æ›æ©Ÿ
----------------------------------------------------------------------
local function updateBarDuringRun()
  local now    = hs.timer.secondsSinceEpoch()
  local buffR  = nearestRemaining()
  local buffTxt = (buffR ~= nil) and fmt_mmss(buffR) or "--:--"
  local idleRem = currentIdleRemain(now)

  if idleRem ~= nil then
    setBar(("è£œæ–½ %s | æ›æ©Ÿ %s"):format(buffTxt, fmt_mmss(idleRem)))
    if idleRem <= IDLE_WARN_LAST and idleRem ~= lastWarnShown then
      lastWarnShown = idleRem
      hs.alert.show(string.format("æ›æ©Ÿå°‡åœ¨ %d ç§’å¾Œåˆ°é”", idleRem), 0.9)
    end
  else
    setBar("è£œæ–½ " .. buffTxt)
  end
end

----------------------------------------------------------------------
-- ä¸»å¾ªç’°
----------------------------------------------------------------------
local function tick()
  if not enabled then return end
  local now = hs.timer.secondsSinceEpoch()
  for _, sk in ipairs(SKILLS) do
    local st = state[sk.name]
    if not st or not st.nextDue then
      scheduleNext(sk, now)
    elseif now >= st.nextDue then
      if castOne(sk) then
        scheduleNext(sk, now)
      else
        state[sk.name].nextDue = now + 2
      end
    end
  end
  updateBarDuringRun()
end

----------------------------------------------------------------------
-- å•Ÿå‹•ï¼åœæ­¢é‚è¼¯
----------------------------------------------------------------------
local function dockBadge(s)
  pcall(function() hs.dockicon.setBadge(s and tostring(s) or "") end)
end

local function castBothNow()
  local now = hs.timer.secondsSinceEpoch()
  for _, sk in ipairs(SKILLS) do
    if castOne(sk) then scheduleNext(sk, now) end
  end
  -- ç•¶è…³æœ¬ä¸»å‹•æ–½æ”¾ï¼Œä¹Ÿè¦–ç‚ºã€Œæœ‰äººæ“ä½œã€ï¼Œé‡ç½®é–’ç½®è¨ˆæ™‚
  log("ğŸ”” castBothNow: reset idle at now =", now)
  updateBarDuringRun()
end

local function startAfterCountdown()
  local function go(n)
    if n == 0 then
      dockBadge("")
      enabled = true
      castBothNow()
      if ticker then ticker:stop() end
      ticker = hs.timer.doEvery(TICK_SEC, tick)
      log("enabled")
      return
    end
    setBar("å•Ÿå‹• " .. tostring(n))
    hs.timer.doAfter(1, function() go(n-1) end)
  end
  go(3)
end

local function stopAll()
  enabled = false
  if ticker then ticker:stop() end
  ticker = nil
  dockBadge("")
  setBar("å¾…æ©Ÿ")
  log("stopped")
end

----------------------------------------------------------------------
-- ç†±éµ
----------------------------------------------------------------------
hs.hotkey.bind({"cmd","alt"}, "F10", function()
  if enabled then stopAll() else startAfterCountdown() end
end)
hs.hotkey.bind({"cmd","alt"}, "F8", function() castBothNow() end)
hs.hotkey.bind({"cmd","alt"}, "F9", function() stopAll() end)

-- åˆå§‹åŒ–
ensureMenuBar()
setBar("å¾…æ©Ÿ")
log("loaded. Press âŒ˜âŒ¥F10 to start (3s countdown).")

return mod